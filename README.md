# Uchicago-2024


# --Case 2 Portfolio Optimization Trading Bot--

It ended up winning 5th place!

# The Prompt: 

In this case, you are a portfolio analyst tasked with allocating a
fund over a ten-year time horizon across six stocks your
research team has selected. To aid you, your company has
provided you with ten years of historical price data for each
stock. Your goal is to develop an algorithm to construct and
rebalance a portfolio aimed at maximizing returns while
simultaneously minimizing returns variance. The trading begins
the day after the last day of data provided.

# Additional Rules:

The exchange trading platform will not be used for this case. Teams are expected to
develop their strategies using our Python stub code and submit their code before the
competition.
We will run each competitor’s portfolio allocation algorithm on a test dataset with
data generated by the same process as the data you are given; this test dataset will
immediately follow the period in the training dataset.
There will be one round, the results of which will be computed prior to the
competition and played back during the competition as if unfolding in real time. As
such, you must submit your final code to the case writers beforehand.

where wi refers to the weight of the ith asset in the portfolio, ri

refers to the return of
that asset, and n refers to the number of assets in the portfolio. While we can
reasonably estimate variances and covariances of asset returns based on historical
data, empirically, historical returns have not been a strong predictor of future
expected return and large covariance matrix estimates tend to be numerically
unstable, leading to practical difficulties in implementing a Markowitz portfolio. Since
the development of MPT, investors and researchers have looked for new ways of
dealing with this problem.

In each timestep, asset prices will be provided and teams will submit portfolio
allocations among the available assets for that period. Your algorithm should
submit a new vector of weights every day. These allocations will be in the form of
weights on each stock: weights can be positive, negative, or zero in each timestep,
but your weights must be in the range [-1, 1]. Note the absolute magnitudes of
your weights don’t matter if the relative magnitudes are the same since we are
grading on Sharpe. We only place limits for simplicity of grading. For more
details ask on Ed. We assume there are no exchange fees or bid-ask spreads in the
market and no liquidity concerns to deal with in allocating your portfolio.
You may use any packages (and any programming language) to study the training
data we will provide, but the submitted portfolio allocation code must be in Python
and will be restricted in dependencies. The environment used to run submitted
competitor code will be Python 3.10 and will only have the NumPy, pandas, scikit-
learn, and SciPy packages installed (alongside base Python). Although advanced
and/or complex machine learning techniques are interesting to study and are
valuable to learn, they are not the focus of this case and are not required for the
purposes of solving this case.
We strongly advise that you test your submission using a similar environment on
your local machine before submitting your final code; submitted code that does not
compile or that fails to run for any time step will be disqualified for this case and the
team that submitted it will receive 0 points. Before final submission, there will be an
opportunity to test if your code compiles and runs properly (note that the Sharpes
yielded from this test will not be indicative of what your actual Sharpe ratio will be).
